## 2. Metaphors
[Charles W. Bachman "The programmer as navigator"](http://dl.acm.org/citation.cfm?id=362534)

Once the old theory has been discarded, it seems incredible that anyone ever believed it at all. More fantastically, people who believed the old theory trought the new theory was just as ridiculous then as you think the old theory now.

Building a four-foot tower requires a steady hand, a level surface, and 10 undamaged beer cans. Building a tower 100 times that size doesn't merely require 100 times as many beer cans. It requires a different kind of planning and construction altogether.

Ripping out a wall and moving it six inches is expensive... You have to make the design as good as possible, so that you don't waste time fixing mistakes that could have been avoided.

[Robert W. Floyd "The paradigms of programming"](http://dl.acm.org/citation.cfm?id=359140)

## 3. Upstream Prerequisites

If you emphasize quality at the end of a project, you emphasize system testing, which is only one part of a complete quality-assurance strategy, and it's not the most influential part.

The principle is to find an error as close as possible to the time at whcih it was introduced. The longer the deffect stays, the more expenses you need to fix it.

The *first prerequisite* you need to fulfill is a clear statement of the problem that the system is supposed to solve, called *problem defenition*.

Architectural components:
- program organisation
- major classes
- data design
- business rules
- user interface design
- resource management
- security
- performance
- scalability
- interoperability
- internationalization
- input/output
- error processing *
- fault tolerance
- architectural feasibility
- overengineering
- buy-vs-build decisions
- reuse decisions
- change strategy
- general architecture quality *

## 4. Key Construction Decisions

In a complex program, architectural guidelines give the program structural balance and construction guidelines provides low-level harmony, architecting each class as a faithful part of a comprehensive design.

Programmers who program "in" a language limit their thoughts to constructs that the language directly supports, if the language tools a primitive, the programmer's thoughts will also be ptrimitive.

Programmers who programm "into" a language first decide what thoughts they want to express, and then they determine how to express those thoughts using the tools provided by their specific language. 
